# Kubernetes com Flux CD

Instala√ß√£o e configura√ß√£o da automa√ß√£o de Deploy dos manifestos no k8s

Nesse passo a passo utilizamos o flux cli e kubectl para realizar a cria√ß√£o e monitoramento dos manifestos dentro do
cluster kubernetes.

1. [Configura√ß√£o do ambiente (AZ / Kubectl / Flux)](#configura√ß√£o-do-ambiente-az--kubectl--flux)
2. [Sincroniza√ß√£o autom√°tica dos arquivos de manifestos](#sincroniza√ß√£o-autom√°tica-dos-arquivos-de-manifestos)
3. [Automa√ß√£o para deploy de vers√£o de containers](#automa√ß√£o-para-deploy-de-vers√£o-de-containers)

## Configura√ß√£o do ambiente (AZ / Kubectl / Flux)

1. [Instala√ß√£o kubectl](https://kubernetes.io/docs/tasks/tools/#kubectl)
2. Conectar sua m√°quina local com a Azure e Cluster
    1. [Instala√ß√£o do Azure CLI](https://docs.microsoft.com/pt-br/cli/azure/install-azure-cli?view=azure-cli-latest).

       Verifique a instala√ß√£o com o comando abaixo, que dever√° retornar a vers√£o do CLI:
       > az version

    2. Realize o login no az:
       > az login
    3. Conecte seu az com o cluster k8s
        1. Acesse seu AKS dentro do [portal da Azure](https://portal.azure.com/)
        2. Clique em Conectar
        3. Execute os comandos que s√£o mostrados no lado direito da tela:
           > az account set --subscription uuid-subscri√ß√£o
           >
           > az aks get-credentials --resource-group Nome_Grupo_Recurso --name Nome_Cluster_k8s

           ![Dashboard AKS](dashboard_aks.png)
        4. Verifique com o kubectl se est√° conectado com o cluster na azure com:
           > kubectl cluster-info
           >
           > Retorno:
           >
           >   Kubernetes control plane is running at https://
           >
           >   CoreDNS is running at https://
           >
           >   Metrics-server is running at https://
        5. Pronto, agora temos acesso ao cluster AKS, portanto **tome muito cuidado**.

4. [Instala√ß√£o Flux CLI](https://fluxcd.io/docs/installation/#install-the-flux-cli)
    1. Verifique a instala√ß√£o com:
       > flux -v

## Sincroniza√ß√£o autom√°tica dos arquivos de manifestos

Agora com o ambiente configurado e conectado com o cluster, vamos realizar a configura√ß√£o da sincroniza√ß√£o do git para
deploy autom√°tico de manifestos.

Requisitos:

* kubectl acessando um cluster
* flux cli
* Reposit√≥rio no github com os manifestos (arquivos yaml) do cluster como este de exemplo

**Aten√ß√£o ao caminho das pastas/arquivos, pois dependo do S.O. utilizado pode ser necess√°rio alterar as barras**

1. Abra um terminal e entre na pasta raiz do reposit√≥rio git.
    * Caso n√£o tenha crie uma pasta chamada flux-system
2. Inicie o flux com o comando:
   > ```shell
   > flux install --export ./flux-system/gotk-components.yaml
   > ```
   > Com isso ser√° criado um arquivo gotk-components.yaml dentro da pasta flux-system, esse arquivo ir√° conter todos os recursos necess√°rios para o flux realizar as opera√ß√µes.
3. Aplique a configura√ß√£o do flux no cluster
   > ```shell 
   > kubectl apply -f ./flux-system/gotk-components.yaml
   > ```
   > Esse comando ir√° aplicar os recursos do flux que criamos no passo 2 dentro do cluster.
4. Cheque recursos do flux
   > ```shell
   > flux check
   > ```
   > Esse comando ir√° checar se todos os recursos do flux foram criados e se est√£o rodando corretamente no cluster.
5. Criar recurso do Git
   > ```shell
   > flux create source git <nome-git> \ 
   >    --git-implementation=libgit2 \ 
   >    --url=ssh://git@github.com/<caminho-repositorio> \ 
   >    --branch=main \ 
   >    --ssh-key-algorithm=rsa \ 
   >    --interval=1m
   > ```
   > Ao rodar esse comando, ir√° mostrar uma chave rsa de deploy no terminal. Essa chave dever√° ser inclu√≠da no reposit√≥rio github antes de prosseguir.
   >
   > 1. Acesse o repo
   > 2. V√° em Settings
   > 3. No m√≥dulo "Security", clique em Deploy Keys
   > 4. Adicione a key clicando em "Add deploy key" **Aten√ß√£o: marcar a op√ß√£o "Allow write access"**
   >
   > Ap√≥s a cria√ß√£o da key, volte ao terminal e prossiga digitando "s" ou "y" e aguarde a finaliza√ß√£o.
   >
   > Para verificar se o recurso foi criado rode o comando:
   > ```shell
   > kubectl get gitrepositories --all-namespaces
   > ```
   >
   > Esse recurso √© respons√°vel por manter o repositorio git sincronizado. A cada intervalo de tempo, informado no parametro interval, o recurso ir√° fazer sincronizar o repo (git pull).
6. Exportar recurso Git para arquivo yaml
   > Ap√≥s a cria√ß√£o do recurso do Git, precisamos salvar as configura√ß√µes em um manifesto yaml.
   >
   > Rode o comando:
   > ```shell
   > flux export source git <nome-aplicacao> > ./flux-system/gotk-sync.yaml
   > ```
   > Ser√° criado um arquivo gotk-sync.yaml dentro da pasta flux-system

7. Criar recurso do kustomization
   > ```shell
   > flux create kustomization <nome-kustomization> \ 
   >    --source=<nome-git> \ 
   >    --path=./deploy/testing \ 
   >    --prune=true \ 
   >    --interval=1m
   > ```
   > **Voc√™ pode mudar o path de acordo com seu repositorio**
   >
   > Ao rodar esse comando, ser√° criado o recurso Kustomization. Esse recurso √© respons√°vel por pegar os arquivos do repositorio dentro do path informado via parametro e fazer a aplica√ß√£o dos manifestos dentro do cluster.
   >
   > Para verificar se o recurso foi criado rode o comando:
   > ```shell
   > kubectl get kustomization --all-namespaces
   > ```
8. Exportar recurso Kustomization para arquivo yaml
   > Ap√≥s a cria√ß√£o do recurso do Kustomization, precisamos salvar as configura√ß√µes em um manifesto yaml.
   >
   > Rode o comando:
   > ```shell
   > flux export kustomization <nome-aplicacao> >> ./flux-system/gotk-sync.yaml
   > ```
   > Ser√° atualizado o arquivo gotk-sync.yaml dentro da pasta flux-system

Pronto, agora temos nosso cluster k8s sincronizado com o reposit√≥rio git. Todos as altera√ß√µes que s√£o realizadas nos
manifestos que est√£o no git, ser√£o sincronizados no cluster, de forma autom√°tica. ü§©ü§©ü§©

Caso voc√™ precise realizar altera√ß√µes relacionadas aos recursos do Git ou Kustomization, voc√™ pode alterar o manifesto (
/flux-system/gotk-sync.yaml) e aplicar ele no cluster:

```shell
kubectl apply -f ./flux-system/gotk-sync.yaml
```

Com isso os recursos contidos nesse manifestos ser√£o atualizados no cluster.

Para verificar se os recursos da aplica√ß√£o est√£o rodando no cluster, rode os comandos normalmente de get, exemplo:

```shell
kubectl get pods --all-namespaces
```

Retornara todos os pods de todos os namespaces

Caso voc√™ queira ver os logs do flux, rode o comando abaixo:

```shell
flux logs --all-namespaces --since=2m
```

## Automa√ß√£o para deploy de vers√£o de containers

Agora com o ambiente configurado, nosso cluster sincronizado com o git. Temos que realizar o deploy dos containers
automaticamente no cluster, respeitando as vers√µes.

Requisitos

* kubectl acessando um cluster
* flux cli
* Reposit√≥rio no github com os manifestos (arquivos yaml) do cluster, pode usar este repo como exemplo
* ACR configurado e com algum container
    * **Aten√ß√£o: Caso o registry for privado √© necess√°rio criar um manifesto Secret para o k8s conseguir acessar os
      containers. Explico um pouco sobre isso no passo 2**

1. Instalando componentes no cluster
   > Rode o comando:
   > ```shell
   > flux install --components-extra=image-reflector-controller,image-automation-controller \ 
   >    --export > ./flux-system/gotk-components.yaml
   > 
   > Verifique se n√£o quebrou nada:
   > 
   > flux check
   > ```
2. Acessando ACR com o k8s
   > Vamos criar um recurso no k8s chamado ImageRepository, esse recurso tem como fun√ß√£o se conectar no acr e visualizar o container com suas vers√µes.
   > 
   > **Segue um exemplo para o parametro image:** 
   >
   > meu-acr-registry.azurecr.io/meu-container
   > ```shell
   > flux create image repository <nome-do-repository> \
   >    --image=<url-do-acr-com-imagem> \
   >    --interval=1m \ 
   >    --namespace=<namespace-aplicacao> \
   >    --secret-ref=<nome-recurso-secret> \
   >    --export > ./deploy/testing/<nome-aplicacao>-testing-registry.yaml
   > ```
   > 
   > Ao executar esse comando, ser√° criado o recurso e o manifesto. Por√©m temos que nos atentar a dois parametros: namespace e secret-ref.
   >
   > Esses parametros s√£o muito importantes pois o recurso ImageRepository ir√° acessar o ACR e o ACR √© privado e para acessar precisamos passar as credencias. 
   > Para isso utilizamos o parametro secret-ref e no valor colocamos o nome de um recurso Secret e para que tudo funcione e possamos separar nossos ambientes em namespaces, precisamos que o Secret e o ImageRepository estejam no mesmo namespace e por isso colocamos a tag namespace.
   > 
   > Resumindo, criamos o ImageRepository no mesmo namespace da nossa aplica√ß√£o, assim podemos ter repositorys de diferentes namespaces, exemplo: dev, testing e production; E tamb√©m, nesse namespace, precisamos ter um secret contendo as chaves de acesso ao ACR.
   > 
   > Para gerar o secret de uma forma f√°cil, podemos usar o kubectl:
   > ```shell
   > kubectl create secret docker-registry <NOME_DO_SEGREDO> \ 
   >    --docker-server <NOME_DO_REGISTRO>.azurecr.io \
   >    --docker-username=<USUARIO> \
   >    --docker-password=<SENHA> \
   >    --output=yaml
   > ```
   > Salve o yaml e crie um arquivo manifesto dentro da pasta de sua aplica√ß√£o
   > 
   > O usu√°rio e senha, voc√™ consegue acessando o ACR no portal azure:
   >    1. Acesse o registro de container
   >    2. No m√≥dulo de configura√ß√µes, clique em "Chaves de Acesso"
   >    3. Marque a op√ß√£o "Usu√°rio administrador"
   >    4. Usu√°rio √© o campo: "Nome de usu√°rio"
   >    5. Senha √© o campo: "password"
   >
   > Agora com tudo criado e configurado, vamos checar se nosso ImageRepository est√° funcionando:
   > ```shell
   > flux get image repository --all-namespaces
   > ```
   > Esse comando dever√° retornar o repository criado, com a mensagem: "successful scan, found X tags"

3. Criando politica de versionamento
   > Com o nosso ImageRepository criado e rodando, vamos criar o recurso chamado ImagePolicy. Esse recurso tem como fun√ß√£o resgatar a "ultima imagem" do container. N√£o s√≥ a ultima, voc√™ pode configurar como bem entender.
   > 
   > ```shell
   > flux create image policy <nome-da-policy> \ 
   >    --image-ref=<nome-do-repository> \
   >    --select-alpha=asc \ 
   >    --filter-regex='^v(?P<ts>\d.\d.\d)-beta$' \ 
   >    --filter-extract='$ts' \ 
   >    --export > ./deploy/testing/meu-app-testing-policy.yaml
   > ```
   > 
   > Ao executar o comando, o flux ir√° criar a policy, vou explicar os parametros.
   > 
   > **image-ref** referencia para qual imagem essa policy ser√° aplicada.
   >
   > **select-alpha** Diz como queremos que a policy se comporte com base na tag, no caso √© ordem alfab√©tica. Temos outras op√ß√µes, voc√™ ter√° que ver qual mais se adequa, peguei de exemplo a mais complexa. Mas existem: --select-numeric --select-semver. Voc√™ pode consultar a documenta√ß√£o para entender mais: [ImagePolicy](https://fluxcd.io/docs/cmd/flux_create_image_policy/)
   >
   > **filter-regex** Montamos um regex para pegar apenas a vers√£o da tag e jogar para uma v√°riavel de nome "ts". Caso sua tag seja diferente, dever√° adapatar o regex ou utilizar um seletor que mais se ad√©que ao seu cen√°rio.
   >
   > **filter-extract** Pegamos do regex a variavel "ts" e extra√≠mos ela para o seletor fazer o a ordena√ß√£o.
   >
   > Resumindo, temos v√°rias imagens com diferentes vers√µes, mas respeitando a nomenclatura: vX.X.X-beta. Nosso regex pega apenas os n√∫meros da vers√£o, no caso X.X.X e nosso extrator diz para o seletor que deve usar esse valor como parametro e pegar na ordem afabetica, do maior pro menor. Utilizamos alfabetica pois temos "." 1.0.0
   > 
   > Para verificar se tudo est√° certo e que a policy est√° pegando a vers√£o correta, rodamos o comando:
   > ```shell
   > flux get image policy --all-namespaces
   > ```
   > 
   > Aqui voc√™ pode ficar testando qual a melhor forma para extrair a vers√£o do container do seu jeito.

4. Atualizando manifestos com nova vers√£o
   > Agora chegamos a √∫ltima etapa de cria√ß√£o de recursos! Com o ImageRepository consultando nosso container e vers√µes, nossa ImagePolicy resolvendo a √∫ltima vers√£o do container. Agora s√≥ precisamos atualizar os manifestos para pegarem sempre a vers√£o correta do container. Para isso vamos criar o recurso ImageUpdateAutomation. Tem como fun√ß√£o atualizar o arquivo de manifesto e subir a altera√ß√£o no git com um commit baseado na ImagePolicy. Vamos l√°!
   >
   > ```shell
   > flux create image update <nome-da-automacao> \ 
   >    --namespace=<namespace-aplicacao>
   >    --git-repo-ref=<nome-git> \ 
   >    --git-repo-namespace=flux-system \ 
   >    --git-repo-path="./deploy/testing" \ 
   >    --checkout-branch=main \ 
   >    --push-branch=main \ 
   >    --author-name=automation-fluxcdbot \ 
   >    --author-email=automation-fluxcdbot@botfluxcd.com.br \ 
   >    --commit-template="chore: update container version to {{range .Updated.Images}}{{println .}}{{end}}" \ 
   >    --export > ./deploy/testing/flux-system-automation.yaml
   > ```
   > 
   > Ao executar o comando, pronto temos a automa√ß√£o, o flux ir√° criar a ImageUpdateAutomation, por√©m ainda n√£o vai funcionar pois precisamos criar um marcado, mas antes uma breve explica√ß√£o de alguns parametros.
   >
   > **git-repo-ref** referencia para qual GitRepository essa automa√ß√£o ir√° se conectar.
   >
   > **git-repo-namespace** referencia qual name space nosso GitRepository est√°. S√≥ uma observa√ß√£o, o GitRepository criamos na segunda etapa desse documento, por√©m n√£o definimos um namespace e quando n√£o define, o flux coloca como default o namespace flux-system e tudo bem ele ficar nesse namespace default, pois todos os outros namespaces v√£o utilizar esse GitRepository, de qualquer forma, voc√™ pode personalizar conforme seu cen√°rio.
   >
   > **git-repo-path** referencia para qual pastas a automa√ß√£o vai realizar as altera√ß√µes, ou seja, todos os arquivos manifestos nessa pasta a automa√ß√£o vai verificar e alterar conforme a policy.
   >
   > **checkout-branch** branch de checkout
   >
   > **push-branch** branch que ser√° realizada o push.
   >
   > **commit-template** Aqui √© interessante, podemos personalizar a mensagem de commit, caso voc√™ queira utilizar alguma conven√ß√£o do seu projeto. No exemplo, coloquei seguindo a [Conventional Commits](https://www.conventionalcommits.org/en/v1.0.0/).

5. Colocando marcadores
   > Pronto, agora com tudo configurado e funcionando. Precisamos colocar um marcado em nossos manifestos que usam container. Assim o ImagePolicy consegue identificar qual container editar.
   > 
   > Para adicionar √© bem simples, abra o manifesto que utiliza o container, por exemplo um Deployment e na linha que chama o container colocamos o marcador. Como no exemplo abaixo:
   > ```yaml
   > apiVersion: apps/v1
   > kind: Deployment
   > metadata:
   >  name: deployment-meu-app
   >  namespace: <namespace-aplicacao>
   > spec:
   >  replicas: 1
   >  selector:
   >  matchLabels:
   >    app: meu-app
   >  template:
   >    metadata:
   >      name: pod-meu-app
   >      labels:
   >        app: meu-app
   >    spec:
   >      containers:
   >        - name: docker-meu-app
   >          image: <NOME_DO_REGISTRO>.azurecr.io/<nome-do-container>:v1.0.2-beta # {"$imagepolicy": "<namespace-aplicacao>:<nome-da-policy>"}
   >          ports:
   >            - containerPort: 3000
   >      imagePullSecrets:
   >        - name: <NOME_DO_SEGREDO>
   > ```


